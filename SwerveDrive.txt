
public SwerveDrive {
    public final double L = LENGTH_YOU_WROTE;
    public final double W = WIDTH_YOU_WROTE;
    

    public void drive(double x1, double y1, double x2) {
        double r = Math.sqrt ((L*L) + (W * W));
        y1 *= -1;

        //the L/r and W/r are correctional, they create an angle that defaults to 45 degrees without input on the the first joystick
        //this makes x2 primarly be used for turning? 
        //if x2 is not used all of the wheels will have the same angle
        double a = x1 - x2 * (L / r);
        double b = x1 + x2 * (L / r);
        double c = y1 - x2 * (W / r);
        double d = y1 + x2 * (W / r);

        double backRightSpeed = Math.sqrt((a * a) + (d * d));
        double backLeftSpeed = Math.sqrt((a * a) + (c * c));
        double frontRightSpeed = Math.sqrt((b * b) + (d * d));
        double frontLeftSpeed = Math.sqrt((b * b) + (c * c));

        //Math.atan returns the angle that the inputs would make on the unit circle 
        //the output range is [-pi, pi]
        //dividing by pi creates an output range of [-1,1] 
        //which our motors can accept as input 


        double backRightAngle = Math.atan2 (a , d) / Math.pi;
        double backLeftAngle = Math.atan2 (a , c) / Math.pi;
        double frontRightAngle = Math.atan2 (b , d) / Math.pi;
        double frontLeftAngle = Math.atan2(b , c) / Math.pi;
    }
}

public WheelDrive {
    //this would be were we would set up the motors and the pid controller
    //each motor would have a speed and an angle that they could be
}

public void drive(double speed, double angle) {
    speedMotor.set (speed);

    //angle 1 or -1 it will setPoint to be 0
    double setPoint = angle * (MAX_VOLTS * .5) + (MAX_VOLTS * .5);
    
    //bounding the setPoint so that it is within (0, MAX_VOLTS)
    //this won't just be a round to nearest endpoint

    pidController.setPoint (setPoint);


}
